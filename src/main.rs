//! Must be compiled with stable-i686-pc-windows-msvc as the game is 32 bit
//! Currently will only work in debug compile by default as that is where the
//! dll is generated ### Todo
//! - Speedhack
//! - AimBot
//! - ~~Split into two crates~~
//! - Better error handling on opening game (Half done)
//! - Improve user input of the DLL path and process name
//! - Implement a check for the expected memory state before injecting the cheat
//! - Write Code Cave for an exisiting easy hack
//! - Hook a process
#![warn(missing_docs)]

use anyhow::{bail, Result};

mod wynapi;
use wynapi::flags::*;

/// Entry Point, here two variables currently need changed by the user. "dll"
/// and "PROCESS" the dll is the path to the dll we want to inject and PROCESS
/// is the string that the process id we are searching for contains
fn main() {
    // Take the first command line Arg or defult to injecting notepad.exe
    let target: String =
        std::env::args().nth(1).unwrap_or("notepad.exe".to_owned());

    let dll = "target/debug/deps/cheatlib.dll";

    inject(&target, dll);
}
/// Find the Process id from a &[str]
/// Caveat: it returns the first PID it finds, even if their are multiple
fn get_pid_from_name(process_name: &str) -> Result<u32> {
    // Gets all running processes
    let pids = wynapi::enum_processes()?;
    let process_name = process_name.to_lowercase();
    for pid in &pids {
        // Open each proccess from its PID
        let handle = wynapi::open_process(
            *pid,
            PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
        );
        if let Some(h) = handle {
            // Get the process name
            let module_name =
                wynapi::get_module_base_name_a(h, core::ptr::null_mut())?
                    .to_lowercase();
            // Close the handle once we are done
            wynapi::close_handle(h)?;
            if module_name == process_name {
                return Ok(*pid as u32);
            }
        }
    }
    bail!("Could not find process with name `{process_name}`")
}
///Injects the DLL generated by cheat lib into the process ID found
fn inject(process_name: &str, dll: &str) {
    // We need the full DLL path
    let dll_path: String = std::fs::canonicalize(dll)
        .expect("DLL not found")
        .to_str()
        .unwrap()
        .replace("\\\\?\\", "");
    let dll_path_len: usize = dll_path.len();

    // Get the pid from the given process name
    let pid = get_pid_from_name(&process_name).unwrap();

    // Get the address of the LoadLibaryA Function, Module is case insensitive
    // target is case ensitive
    let loadlib_addr =
        wynapi::get_proc_address("KernelBase.dll", "LoadLibraryA").unwrap();

    // Open the target application with permissions to create the DLL and write
    // memory
    let process_handle = if let Some(handle) = wynapi::open_process(
        pid,
        PROCESS_CREATE_THREAD
            | PROCESS_VM_WRITE
            | PROCESS_VM_OPERATION
            | PROCESS_QUERY_INFORMATION
            | PROCESS_VM_READ,
    ) {
        handle
    } else {
        panic!("Could not open process");
    };

    // Allocate inside target process with length of the [dll_path] and then 
    // get the address returned
    let alloc_base_addr = wynapi::virtual_alloc_ex(
        process_handle,
        dll_path_len,
        MEM_COMMIT | MEM_RESERVE,
        PAGE_READWRITE,
    )
    .unwrap();

    // Write the **file path** into the target process memory
    let _bytes_written = wynapi::write_process_memory(
        process_handle,
        alloc_base_addr,
        dll_path.as_ptr(),
        dll_path_len,
    )
    .unwrap();

    // Create a thread inside the DLL and run our function LoadLibraryA with a
    // parameter of the base address of our allocation, of which we
    // previously wrote our DLL full path
    let (thread_handle, _thread_id) = wynapi::create_remote_thread(
        process_handle,
        loadlib_addr as *const u8,
        alloc_base_addr as *const u8,
    )
    .unwrap();

    // Give the process time to signal it is up
    wynapi::wait_for_single_object(thread_handle, 5000).unwrap();

    // Free the thread handle the thread, we are done with it. It is on its own
    // now!
    wynapi::close_handle(thread_handle).unwrap();

    // Free the thread handle the thread, we are done with it. It is on its own
    // now!
    wynapi::close_handle(process_handle).unwrap();
}
