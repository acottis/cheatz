//! Must be compiled with stable-i686-pc-windows-msvc as the game is 32 bit
//! Currently will only work in debug compile by default as that is where the dll is generated
//! ### Todo
//! - Speedhack
//! - AimBot
//! - ~~Split into two crates~~
//! - Better error handling on opening game (Half done)
//! - Improve user input of the DLL path and process name
//! - Implement a check for the expected memory state before injecting the cheat
//! - Write Code Cave for an exisiting easy hack
//! - Hook a process

#[warn(missing_docs)]

use winapi::um::libloaderapi::{GetProcAddress, LoadLibraryA};
use winapi::um::processthreadsapi::{OpenProcess, CreateRemoteThread };
use winapi::um::handleapi::CloseHandle;
use winapi::um::memoryapi::{VirtualAllocEx, WriteProcessMemory, VirtualFreeEx};
use winapi::um::synchapi::WaitForSingleObject;
use winapi::um::winnt::{PROCESS_CREATE_THREAD, PROCESS_VM_WRITE, PROCESS_VM_OPERATION, MEM_COMMIT, PAGE_READWRITE, MEM_RELEASE, MEM_RESERVE, PROCESS_QUERY_INFORMATION, PROCESS_VM_READ};

use std::process::Command;
///
/// Entry Point, here two variables currently need changed by the user. "dll" and "PROCESS" the dll is the path to the dll we want to inject and PROCESS is the string that the process id we are searching for contains
///
fn main() {

    let dll = "target/debug/deps/cheatlib.dll";
    const PROCESS: &str = "Battlefront";
    
    inject(PROCESS, dll);
}
///
///Uses powershell to find the process ID which contains a specified string
///
fn get_process_id(process: &str) -> Option<(String, u32)>{

    let out_raw = {
        Command::new("powershell.exe")
            .args(&[format!("get-process | Where ProcessName -like \"{}*\" | Select -last 1 | foreach {{Write-Host \"$($_.ProcessName),$($_.id),$($_.Path)\"}}", process)])
            .output()
            .expect("Failed to execute command")
    };

    let out_str = core::str::from_utf8(&out_raw.stdout).expect("Failed to convert pid");

    for line in out_str.lines(){

        let out_split: Vec<&str> = line.split(",").collect();
        let exename: String = out_split[0].to_string();
        let pid: u32 = out_split[1].parse().expect("PID not a number");

        return Some((exename, pid))
    }
    None
}
///
///Injects the DLL generated by cheat lib into the process ID found
///
fn inject(process: &str, dll: &str){

    let (_, proc_id) = match get_process_id(process) {
        Some((proc_name, proc_id)) => {
            println!("Found Process: {}, PID: {}", proc_name, proc_id);
            (proc_name, proc_id)
        },
        None => { 
            println!("Could not get the process containing the text \"{}\" does it exist?", process);
            return
        }
    };
  
    let loadlib_addr = unsafe {
        GetProcAddress(
            LoadLibraryA(
                "kernelbase.dll\0".as_ptr() as *const i8
            ),
            "LoadLibraryA\0".as_ptr() as *const i8
        ) as *const i8
    };
    println!("LoadLibrary at: {:#X?}", loadlib_addr);

    let full_path: String = std::fs::canonicalize(dll).expect("DLL not found").to_str().unwrap().replace("\\\\?\\", "");
    let path_size: usize = full_path.len();
    println!("{}, Len: {}", full_path, path_size);

    // Open the target application with permissions to create the DLL and write memory
    let handle_process = unsafe{
        OpenProcess(PROCESS_CREATE_THREAD | PROCESS_VM_WRITE |
        PROCESS_VM_OPERATION | PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
        0,
        proc_id)
    };
    assert!(handle_process != core::ptr::null_mut(), "Process Handle is null");
    println!("Process Handle: {:?}", handle_process);

    let my_base_address = unsafe{
        VirtualAllocEx(handle_process,
            core::ptr::null_mut(), 
            path_size, 
            MEM_COMMIT | MEM_RESERVE, 
            PAGE_READWRITE)};
    println!("Allocation Base: {:?}", my_base_address);
    assert!(!my_base_address.is_null(), "Allocation failed");
    
    let mut bytes_written_to_process = 0;

    unsafe {assert!(
        WriteProcessMemory(
            handle_process,
            my_base_address,
            core::mem::transmute(full_path.as_ptr()), 
            path_size, 
            &mut bytes_written_to_process
        ) != 0, "Could not write to process") };

    println!("Wrote {} bytes", bytes_written_to_process);

    let handle_thread = unsafe {
        CreateRemoteThread(handle_process,
            core::ptr::null_mut(), 
            0, 
            core::mem::transmute(loadlib_addr), 
            my_base_address, 
            0, 
            core::ptr::null_mut())
    };
    assert!(!handle_thread.is_null(), "Could not create thread in remote process");
    println!("Thread Handle: {:?}", handle_thread);

    let status = unsafe {WaitForSingleObject(handle_thread, 0xFFFFFFFF)};

    println!("Wait Status: {:X}",status);

    unsafe {assert!(CloseHandle(handle_thread) != 0, "Thread handle failed to close sucessfully")};

    unsafe {VirtualFreeEx(handle_process, core::mem::transmute(full_path.as_ptr()), 0, MEM_RELEASE)};

    unsafe {assert!(CloseHandle(handle_process) != 0, "Process Handle failed to close sucessfully")};
}